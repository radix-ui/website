---
title: Scroll Area
name: scroll-area
version: 0.0.1-13
description: Augments native scroll functionality for custom, cross-browser styling.
navGroup: components
features:
  - Track sits on top of the scrollable content, taking up no space.
  - Scrolling is native; no underlying position movements via CSS transformations.
  - Shims pointer behaviors only when interacting with the controls, so keyboard controls are unaffected.
  - Progressively enhanced so that content is avalaible on devices where custom controls aren't supported.
---

## Installation

Install the component from your command line.

```bash
npm install @radix-ui/react-scroll-area
```

## Anatomy

Import the components and piece the parts together.

```jsx
import {
  ScrollArea,
  Viewport,
  ScrollbarX,
  ScrollbarY,
  ButtonStart,
  ButtonEnd,
  Track,
  Thumb,
  Corner,
} from '@radix-ui/react-scroll-area';

export default () => (
  <ScrollArea>
    <Viewport />

    <ScrollbarX>
      <ScrollTrack>
        <ButtonStart />
        <ScrollThumb />
        <ButtonEnd />
      </ScrollTrack>
    </ScrollbarX>

    <ScrollbarY>
      <ScrollTrack>
        <ButtonStart />
        <ScrollThumb />
        <ButtonEnd />
      </ScrollTrack>
    </ScrollbarY>

    <Corner />
  </ScrollArea>
);
```

## Basic Example

Create your styled scroll area component from the primitive parts.

**Note:** This example uses [Stitches](https://stitches.dev) but any styling solution is [compatible](../overview/styling).

```jsx live manual
// import { styled } from 'path-to/stitches.config';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';

const { SCROLL_AREA_CSS_PROPS } = ScrollAreaPrimitive;

const ScrollArea = styled(ScrollAreaPrimitive.Root, {
  position: 'relative',
  // Root z-index set to 0 so we can set a new baseline for its children Apps may need to override
  // this if they have higher z-indices that conflict with their scrollbars, but they should not
  // need to change the z-indices for other elements in the tree.
  zIndex: 0,
  maxWidth: '100%',
  maxHeight: '100%',
  '&[data-dragging], &[data-scrolling]': {
    pointerEvents: 'auto',
  },
  '& [data-radix-scroll-area-position]::-webkit-scrollbar': {
    display: 'none',
  },
});

const Viewport = styled(ScrollAreaPrimitive.Viewport, {
  zIndex: 1,
  position: 'relative',
});

const ScrollbarY = styled(ScrollAreaPrimitive.ScrollbarY, {
  zIndex: 2,
  position: 'absolute',
  userSelect: 'none',
  transition: '300ms opacity ease',
  width: 8,
  right: 0,
  top: 0,
  bottom: 0,
});

const ScrollTrack = styled(ScrollAreaPrimitive.Track, {
  zIndex: -1,
  position: 'relative',
  width: '100%',
  height: '100%',
});

const ScrollThumb = styled(ScrollAreaPrimitive.Thumb, {
  backgroundColor: 'gainsboro',
  position: 'absolute',
  top: 0,
  left: 0,
  userSelect: 'none',
  borderRadius: 9999,
  willChange: `var(${SCROLL_AREA_CSS_PROPS.scrollbarThumbWillChange})`,
  height: `var(${SCROLL_AREA_CSS_PROPS.scrollbarThumbHeight})`,
  width: `var(${SCROLL_AREA_CSS_PROPS.scrollbarThumbWidth})`,
});

export default () => (
  <div style={{ height: 500 }}>
    <ScrollArea>
      <Viewport>
        <div
          style={{
            width: 200, // why cant I do 100% here?
            height: 1000,
            backgroundImage:
              'repeating-linear-gradient(0deg, dodgerblue, dodgerblue 10px, transparent 10px, transparent 20px)',
          }}
        />
      </Viewport>

      <ScrollbarY>
        <ScrollTrack>
          <ScrollThumb />
        </ScrollTrack>
      </ScrollbarY>
    </ScrollArea>
  </div>
);
```

## Accessibility

In most cases, it's best to rely on native scrolling and work with the customisation options available in CSS. Sometimes this isn't enough, but recreating scroll behavior is incredibly hard work, process intensive, and requires a great deal of client-side code. `ScrollArea` provides additional customisability that maintains the browser's native scroll beahvior while replacing the visual controls with stylable parts. This preserves many great accessibility features of native scrolling, as well as improved performance over a complete custom reimplementation. 

Further, scrollbar behavior is inconsistent across platforms. Native scroll features, such as keyboard controls, should work as the user would expect in a native overflowing element because that's what we provide under the hood.

## API Reference

### ScrollArea

`ScrollArea` is the root component.

<PropsTable
  data={[
    {
      name: 'overflowX',
      type: '"auto" | "hidden" | "scroll" | "visible"',
      typeSimple: 'enum',
      default: '"auto"',
      description: (
        <span>
          Overflow behavior for the x-axis. Mirrors the{' '}
          <Code>overflow-x</Code> CSS property.
        </span>
      ),
    },
    {
      name: 'overflowY',
      type: '"auto" | "hidden" | "scroll" | "visible"',
      typeSimple: 'enum',
      default: '"auto"',
      description: (
        <span>
          Overflow behavior for the y-axis. Mirrors the{' '}
          <Code>overflow-y</Code> CSS property.
        </span>
      ),
    },
    {
      name: 'scrollbarVisibility',
      type: '"always" | "scroll" | "hover"',
      typeSimple: 'enum',
      default: '"hover"',
      description: (
        <span>
          Describes the nature of scrollbar visibility, similar to how
          the scrollbar preferences in MacOS control visibility of
          native scrollbars.
          <br />
          <br />
          <Code>"always"</Code> means that scrollbars are always visible
          when content is overflowing on a given axis.
          <br />
          <Code>"scroll"</Code> means that scrollbars are visible when
          the user is scrolling along its corresponding axis.
          <br />
          <Code>"hover"</Code> when the user is scrolling along its corresponding
          axis and when the user is hovering over scrollable area.
        </span>
      ),
    },
    {
      name: 'scrollbarVisibilityRestTimeout',
      type: 'number',
      default: '600',
      description: (
        <span>
          If <Code>scrollbarVisibility</Code> is set to either{' '}
          <Code>"scroll"</Code> or <Code>"hover"</Code>, this prop
          determines the length of time, in milliseconds, before the
          scrollbars are hidden after the user stops interacting with
          scrollbars.
        </span>
      ),
    },
    {
      name: 'trackClickBehavior',
      type: '"page" | "relative"',
      typeSimple: 'emum',
      default: '"relative"',
      description: (
        <span>
          Describes the action that occurs when a user clicks on the{' '}
          <Code>Track</Code>. When <Code>"relative"</Code>, the{' '}
          <Code>ScrollArea</Code> will jump to a spot relative to
          where the user has clicked in relation to the{' '}
          <Code>Track</Code>. When <Code>"page"</Code>, the{' '}
          <Code>ScrollArea</Code> will initially jump to the next or
          previous page of the viewable area, depending on which
          direction on the <Code>Track</Code> is clicked.
        </span>
      ),
    },
  ]}
/>

### Viewport

`ScrollAreaViewport` is the viewport area of the `ScrollArea`.

### ScrollbarX

`ScrollAreaScrollbarX` is the horizontal scrollbar.

### ScrollbarY

`ScrollAreaScrollbarY` is the vertical scrollbar.

### ButtonStart

`ScrollAreaButtonStart` is the start button in either `ScrollAreaScrollbarX` or `ScrollAreaScrollbarY`.

### ButtonEnd

`ScrollAreaButtonEnd` is the end button in either `ScrollAreaScrollbarX` or `ScrollAreaScrollbarY`.

### Track

`ScrollAreaTrack` is the track inside either `ScrollAreaScrollbarX` or `ScrollAreaScrollbarY`.

### Thumb

`ScrollAreaThumb` is the thumb inside either `ScrollAreaScrollbarX` or `ScrollAreaScrollbarY`.

### Corner

`ScrollAreaCorner` is the corner where both vertical and horizontal scrollbars meet.
